const Report = require('../models/report.model');
const ReportFailure = require('../models/reportFailure.model');
const User = require('../models/user.model');
const Truck = require('../models/truck.model');
const Remolque = require('../models/remolque.model');
const sequelize = require('../config/database');

// Create a new report
const createReport = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { vehicle_type, vehicle_id, vehicle_number, equipment_type, failures } = req.body;
    const operator_id = req.userId;
    
    // Get operator info
    const operator = await User.findByPk(operator_id);
    if (!operator) {
      return res.status(404).send({ message: "Operator not found." });
    }

    // Validate that failures array is not empty
    if (!failures || failures.length === 0) {
      return res.status(400).send({ message: "At least one failure must be reported." });
    }

    // Generate report number (will be auto-generated by trigger)
    const report = await Report.create({
      vehicle_type,
      vehicle_id,
      vehicle_number,
      equipment_type,
      operator_id,
      operator_name: operator.full_name,
      status: 'REVISION'
    }, { transaction });

    // Create failures
    const failurePromises = failures.map(failure => {
      return ReportFailure.create({
        report_id: report.id,
        failure_description: failure.failure_description
      }, { transaction });
    });

    await Promise.all(failurePromises);
    await transaction.commit();

    // Fetch the complete report with failures
    const completeReport = await Report.findByPk(report.id, {
      include: [{
        model: ReportFailure,
        as: 'failures'
      }]
    });

    res.status(201).send(completeReport);
  } catch (error) {
    await transaction.rollback();
    res.status(500).send({ message: error.message });
  }
};

// Get all reports
const getReports = async (req, res) => {
  try {
    const reports = await Report.findAll({
      include: [{
        model: ReportFailure,
        as: 'failures'
      }],
      order: [['created_at', 'DESC']]
    });
    res.status(200).send(reports);
  } catch (error) {
    res.status(500).send({ message: error.message });
  }
};

// Get reports by status
const getReportsByStatus = async (req, res) => {
  try {
    const { status } = req.params;
    const reports = await Report.findAll({
      where: { status },
      include: [{
        model: ReportFailure,
        as: 'failures'
      }],
      order: [['created_at', 'DESC']]
    });
    res.status(200).send(reports);
  } catch (error) {
    res.status(500).send({ message: error.message });
  }
};

// Get single report
const getReportById = async (req, res) => {
  try {
    const { id } = req.params;
    const report = await Report.findByPk(id, {
      include: [{
        model: ReportFailure,
        as: 'failures'
      }]
    });
    
    if (!report) {
      return res.status(404).send({ message: "Report not found." });
    }
    
    res.status(200).send(report);
  } catch (error) {
    res.status(500).send({ message: error.message });
  }
};

// Update report (for admin assignment)
const updateReport = async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { id } = req.params;
    const updateData = req.body;
    
    const report = await Report.findByPk(id, { transaction });
    if (!report) {
      return res.status(404).send({ message: "Report not found." });
    }

    // If assigning a mechanic, update the assigned fields and timestamp
    if (updateData.assigned_mechanic_id) {
      const mechanic = await User.findByPk(updateData.assigned_mechanic_id, { transaction });
      if (!mechanic || mechanic.role !== 'Mecanico') {
        return res.status(400).send({ message: "Invalid mechanic selected." });
      }
      
      updateData.assigned_mechanic_name = mechanic.full_name;
      updateData.assigned_at = new Date();
      updateData.status = 'ASIGNADO';
    }

    // If completing the report
    if (updateData.status === 'FINALIZADO') {
      updateData.completed_at = new Date();
    }

    await report.update(updateData, { transaction });
    await transaction.commit();

    // Fetch updated report with failures
    const updatedReport = await Report.findByPk(id, {
      include: [{
        model: ReportFailure,
        as: 'failures'
      }]
    });

    res.status(200).send(updatedReport);
  } catch (error) {
    await transaction.rollback();
    res.status(500).send({ message: error.message });
  }
};

// Update failure (for admin categorization or mechanic feedback)
const updateFailure = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;
    
    const failure = await ReportFailure.findByPk(id);
    if (!failure) {
      return res.status(404).send({ message: "Failure not found." });
    }

    await failure.update(updateData);
    res.status(200).send(failure);
  } catch (error) {
    res.status(500).send({ message: error.message });
  }
};

// Get available mechanics
const getAvailableMechanics = async (req, res) => {
  try {
    const mechanics = await User.findAll({
      where: { 
        role: 'Mecanico',
        is_active: true 
      },
      attributes: ['id', 'full_name', 'employee_number'],
      order: [['full_name', 'ASC']]
    });
    res.status(200).send(mechanics);
  } catch (error) {
    res.status(500).send({ message: error.message });
  }
};

module.exports = {
  createReport,
  getReports,
  getReportsByStatus,
  getReportById,
  updateReport,
  updateFailure,
  getAvailableMechanics
};